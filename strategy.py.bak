from datetime import date, datetime
from tastytrade import Session, DXLinkStreamer
from tastytrade.instruments import NestedOptionChain, Option
from tastytrade.utils import get_tasty_monthly
import pandas as pd
import logging

logger = logging.getLogger("0dte-strategy")

def get_0dte_expiration_date():
    return date.today()


from tastytrade.instruments import get_option_chain, OptionType
from tastytrade.metrics import get_market_metrics

async def fetch_spx_iv_rank(session: Session) -> float:
    """
    Fetches the IV Rank for SPX.
    """
    logger.info("Fetching SPX IV Rank...")
    try:
        metrics = get_market_metrics(session, ["SPX"])
        if metrics and metrics[0].implied_volatility_index_rank:
            iv_rank = float(metrics[0].implied_volatility_index_rank) # It comes as string or decimal
            logger.info(f"SPX IV Rank: {iv_rank}")
            return iv_rank
    except Exception as e:
        logger.error(f"Error fetching IV Rank: {e}")
    
    return 0.0


async def fetch_spx_option_chain(session: Session):
    """
    Fetches the SPX option chain.
    """
    logger.info("Fetching SPX option chain...")
    symbol = "SPX" 
    
    # get_option_chain returns a Dict[date, List[Option]]
    chain = get_option_chain(session, symbol)
    return chain

def filter_for_0dte(chain: dict):
    """
    Filters the chain for today's expiration.
    Chain is Dict[date, List[Option]]
    """
    today = get_0dte_expiration_date()
    logger.info(f"Looking for expiration: {today}")
    
    # DEBUG Override for testing if today has no 0DTE (uncomment to test)
    # if chain:
    #     today = sorted(chain.keys())[0]
    
    if today in chain:
        logger.info(f"Found 0DTE expiration: {today} with {len(chain[today])} options")
        return chain[today]

    logger.warning(f"No 0DTE expiration found for {today}")
    return None

from tastytrade.dxfeed import Greeks, Quote

# ...

async def get_quote_snapshot(session: Session, symbols: list):
    """
    Fetches a snapshot of quotes for a list of symbols.
    """
    quotes = {}
    if not symbols:
        return quotes
        
    logger.info(f"Fetching quotes for {len(symbols)} symbols...")
    
    async with DXLinkStreamer(session) as streamer:
        await streamer.subscribe(Quote, symbols)
        
        start_time = datetime.now()
        async for event in streamer.listen(Quote):
            if (datetime.now() - start_time).seconds > 5:
                # logger.warning("Timeout waiting for Quotes.")
                break
            
            if isinstance(event, list):
                for e in event:
                     if isinstance(e, Quote):
                        quotes[e.event_symbol] = e
            elif isinstance(event, Quote):
                quotes[event.event_symbol] = event

            if len(quotes) >= len(symbols):
                break
                
    return quotes

async def get_greeks_for_chain(session: Session, options_list: list):
    """
    Subscribes to Greeks for all options in the list to find deltas.
    """
    # options_list is a list of FutureOption objects
    symbols = [o.streamer_symbol for o in options_list]
            
    if not symbols:
        logger.error("No symbols found in expiration.")
        return {}

    logger.info(f"Subscribing to Greeks for {len(symbols)} symbols...")
    
    # Setup Streamer
    greeks_data = {}
    
    async with DXLinkStreamer(session) as streamer:
        await streamer.subscribe(Greeks, symbols)
        
        start_time = datetime.now()
        async for event in streamer.listen(Greeks):
            if (datetime.now() - start_time).seconds > 10:
                logger.warning("Timeout waiting for Greeks.")
                break
            
            # Event handling
            # event is likely the object itself (Greeks object) or list
            # The SDK usually yields the event object
            
            if isinstance(event, list):
                for e in event:
                     # Check type
                     if isinstance(e, Greeks):
                        greeks_data[e.event_symbol] = e
            elif isinstance(event, Greeks):
                greeks_data[event.event_symbol] = event

            if len(greeks_data) >= len(symbols) * 0.9:
                break
            
    return greeks_data

async def find_iron_condor_legs(session: Session, options_list: list, target_delta: float = 0.20):
    """
    Finds the legs for the Iron Condor based on Target Delta.
    """
    greeks = await get_greeks_for_chain(session, options_list)
    
    if not greeks:
        logger.error("No Greeks data found.")
        return None
        
    # Separate Calls and Puts (same as before)
    calls = []
    puts = []
    
    for option in options_list:
        if option.streamer_symbol in greeks:
            delta = float(greeks[option.streamer_symbol].delta)
            if option.option_type == OptionType.CALL:
                calls.append({'symbol': option.streamer_symbol, 'strike': option.strike_price, 'delta': delta})
            elif option.option_type == OptionType.PUT:
                puts.append({'symbol': option.streamer_symbol, 'strike': option.strike_price, 'delta': delta})
            
    # Sort by strike
    calls.sort(key=lambda x: x['strike'])
    puts.sort(key=lambda x: x['strike'])
    
    if not calls or not puts:
         logger.error("No calls or puts found with greeks.")
         return None

    # Find Target Delta (~target_delta for calls, ~-target_delta for puts)
    short_call = min(calls, key=lambda x: abs(x['delta'] - target_delta))
    short_put = min(puts, key=lambda x: abs(x['delta'] + target_delta))
    
    # Find Long Legs ($20 away)
    long_call_strike = short_call['strike'] + 20
    long_put_strike = short_put['strike'] - 20
    
    long_call = min(calls, key=lambda c: abs(c['strike'] - long_call_strike), default=None)
    long_put = min(puts, key=lambda p: abs(p['strike'] - long_put_strike), default=None)
    
    if not long_call or not long_put:
        logger.error(f"Could not find wings. Short Call: {short_call['strike']}, Short Put: {short_put['strike']}")
        return None
        
    legs = {
        'short_call': short_call,
        'long_call': long_call,
        'short_put': short_put,
        'long_put': long_put
    }
    
    # FETCH PRICES
    leg_symbols = [legs[k]['symbol'] for k in legs]
    quotes = await get_quote_snapshot(session, leg_symbols)
    
    for k in legs:
        sym = legs[k]['symbol']
        price = 0.0
        if sym in quotes:
            q = quotes[sym]
            if q.bid_price and q.ask_price:
                price = (q.bid_price + q.ask_price) / 2
            else:
                 price = q.ask_price or q.bid_price or 0.0
        legs[k]['price'] = float(price)
    
    logger.info(f"Selected Legs with Prices: {legs}")
    return legs


async def find_iron_fly_legs(session: Session, options_list: list, target_delta: float = 0.50, wing_width: int = 10):
    """
    Finds the legs for the Iron Fly.
    ATM Short Call and Put (closest to target_delta usually 0.50).
    Long Call at ATM + wing_width.
    Long Put at ATM - wing_width.
    """
    greeks = await get_greeks_for_chain(session, options_list)
    
    if not greeks:
        logger.error("No Greeks data found.")
        return None
        
    # Separate Calls and Puts
    calls = []
    puts = []
    
    for option in options_list:
        if option.streamer_symbol in greeks:
            delta = float(greeks[option.streamer_symbol].delta)
            if option.option_type == OptionType.CALL:
                calls.append({'symbol': option.streamer_symbol, 'strike': option.strike_price, 'delta': delta})
            elif option.option_type == OptionType.PUT:
                puts.append({'symbol': option.streamer_symbol, 'strike': option.strike_price, 'delta': delta})
            
    # Sort by strike
    calls.sort(key=lambda x: x['strike'])
    puts.sort(key=lambda x: x['strike'])
    
    if not calls or not puts:
         logger.error("No calls or puts found with greeks.")
         return None

    # Find ATM Call (closest to target_delta e.g. 0.50)
    # Iron Fly Shorts are at the SAME strike usually.
    # We can just look for the Call closest to 50 delta and match the strike for Put.
    
    atm_call = min(calls, key=lambda x: abs(x['delta'] - target_delta))
    atm_strike = atm_call['strike']
    
    # Verify we have a put at this strike (we should)
    atm_put = next((p for p in puts if p['strike'] == atm_strike), None)
    
    if not atm_put:
        logger.warning(f"No Put found at ATM strike {atm_strike}. Looking specifically for ATM Put.")
        # Fallback: Find Put closest to 0.50 delta (absolute)
        atm_put = min(puts, key=lambda x: abs(abs(x['delta']) - target_delta))
        # If they are different strikes, maybe pick the one closest to spot? 
        # For simplicity, let's force them to be same strike if possible, or close.
        # But standard Iron Fly is same strike.
        if atm_put['strike'] != atm_strike:
             logger.warning(f"ATM Call Strike {atm_strike} != ATM Put Strike {atm_put['strike']}. Using Call Strike as anchor.")
             # Re-find put at call strike if possible
             retry_put = next((p for p in puts if p['strike'] == atm_strike), None)
             if retry_put:
                 atm_put = retry_put
             else:
                 logger.error(f"Cannot find Put at {atm_strike}. Aborting.")
                 return None

    short_call = atm_call
    short_put = atm_put
    
    # Find Long Legs (Wings)
    long_call_strike = atm_strike + wing_width
    long_put_strike = atm_strike - wing_width
    
    long_call = min(calls, key=lambda c: abs(c['strike'] - long_call_strike), default=None)
    long_put = min(puts, key=lambda p: abs(p['strike'] - long_put_strike), default=None)
    
    if not long_call or not long_put:
        logger.error(f"Could not find wings. ATM: {atm_strike}. Long Call needed: {long_call_strike}, Long Put needed: {long_put_strike}")
        return None
        
    legs = {
        'short_call': short_call,
        'long_call': long_call,
        'short_put': short_put,
        'long_put': long_put
    }
    
    # FETCH PRICES
    leg_symbols = [legs[k]['symbol'] for k in legs]
    quotes = await get_quote_snapshot(session, leg_symbols)
    
    for k in legs:
        sym = legs[k]['symbol']
        price = 0.0
        if sym in quotes:
            q = quotes[sym]
            if q.bid_price and q.ask_price:
                price = (q.bid_price + q.ask_price) / 2
            else:
                 price = q.ask_price or q.bid_price or 0.0
        legs[k]['price'] = float(price)
    
    logger.info(f"Selected Iron Fly Legs ({wing_width} wide) at {atm_strike}: {legs}")
    return legs
